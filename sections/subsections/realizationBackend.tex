\subsection{Реализция серверной части.}

\subsubsection{Структура решения.}

\textbf{Структура Controllers:}
\begin{itemize}
	\item{Controllers --- это классы, которые отвечают за обработку HTTP-запросов и возвращают ответы в формате JSON.
			\begin{itemize}
				\item{AdminRequestController --- контроллер, отвечающий за обработку запросов администраторов по работе с запросами.}
				\item{AdminUserController --- контроллер, отвечающий за обработку запросов администраторов по работе с пользователями.}
				\item{AuthController --- контроллер, отвечающий за регистрацию, аутентификацию пользователей.}
				\item{DevUserController --- контроллер, отвечающий за обработку запросов Dev-ами по работе с администраторами}
				\item{StudentRequestController --- контроллер, отвечающий за обработку запросов студентов по работе с запросами.}
				\item{UserController --- контроллер, отвечающий за обработку запросов пользователей по работе с их личными данными.}
			\end{itemize}
		}
	\item{Middlewares --- это классы, промежуточного ПО.
			\begin{itemize}
				\item{ExceptionHandlerMiddleware --- middleware, отвечающий за обработку исключений в приложении.}
			\end{itemize}
		}
	\item{Program.cs --- основной файл инициализации, содержащий конфигурацию сервисов, настройку middleware и запуск сервера.}
\end{itemize}

\textbf{Структура Context:}
\begin{itemize}
	\item{Classes --- это классы взаимодействия с базой данных с помощью паттерна "репозиторий".
			\begin{itemize}
				\item{BaseRepository --- шаблонный класс репозитория, отвечающий за взаимодействие с базой данных. Все следующие репозитории наследуют его для своих сущностей.}
				\item{RefreshTokenRepository --- репозиторий Refresh токенов.}
				\item{RequestRepository --- репозиторий запросов.}
				\item{RespondedPeopleRepository --- репозиторий откликнувшихся на запрос.}
				\item{UserRepository --- репозиторий пользователей.}
				\item{ImageRepository --- репозиторий изображений (пока не реализовано его использование).}
			\end{itemize}
		}
	\item{Interfaces --- это интерфейсы для взаимодействия с базой данных с помощью паттерна "репозиторий".
			\begin{itemize}
				\item{IBaseRepository}
				\item{IRefreshTokenRepository}
				\item{IRequestRepository}
				\item{IRespondedPeopleRepository}
				\item{IUserRepository}
				\item{IImageRepository}
			\end{itemize}
		}
	\item{Context.cs --- настройка контекста взаимодействия с базой данных.}
\end{itemize}

\textbf{Структура Database:}
\begin{itemize}
	\item{Entities --- это классы сущностей.
			\begin{itemize}
				\item{Imgae --- класс сущности изображений.}
				\item{Request --- класс сущности запросов.}
				\item{RefreshToken --- класс сущности Refresh токенов.}
				\item{RespondedPeople --- класс сущности откликнувшихся на запрос.}
				\item{User --- класс сущности пользователей.}
			\end{itemize}
		}
	\item{Enums --- это типы перечислений.
			\begin{itemize}
				\item{StatusCodes --- тип перечисления статусов HTTP.}
			\end{itemize}
		}
	\item{BaseResponse --- это класс ответа для передачи данных в контроллер. }
\end{itemize}

\textbf{Структура Service:}
\begin{itemize}
	\item{Classes --- это классы передачи данных.
			\begin{itemize}
				\item{CurrentRequest --- класс запроса, используемый для передачи данных о запросах, на которые записан пользователь.}
				\item{LoginUser --- класс, используемый для работы с данными, приходящими от клиента для входа в аккаунт пользователя.}
				\item{PrivateRequest --- класс запроса, используемый для передачи данных о запросах с полями недоступными обычным пользователям.}
				\item{PublicRequest --- класс запроса, используемый для передачи данных о запросах с полями доступными обычным пользователям.}
				\item{RequestLog --- класс, используемый для логирования изменений запроса администратором.}
				\item{Token --- класс, хранящий пару токенов: Access Token и Refresh Token.}
			\end{itemize}
		}
	\item{Extentions --- это классы расширения, для добавления методов сущностям.
			\begin{itemize}
				\item{RequestExtentions --- класс расширения, для добавления методов сущности запроса.}
				\item{RespondedPeopleExtentions --- класс расширения, для добавления методов сущности откликнувшихся людей.}
				\item{UserExtentions --- класс расширения, для добавления методов сущности пользователя.}
			\end{itemize}
		}
	\item{Implementations --- это классы реализации логики приложения.
			\begin{itemize}
				\item{AdminRequestServices --- класс реализации логики администраторов по взаимодействию с запросами.}
				\item{AdminUserServices --- класс реализации логики администраторов по взаимодействию с пользователями.}
				\item{AuthServices --- класс реализации логики аутентификации пользователей.}
				\item{CachingServices --- класс реализации логики кеширования данных.}
				\item{DevUserServices --- класс реализации логики Dev-ов по взаимодействию с администраторами.}
				\item{HashingServices --- класс реализации логики хеширования паролей пользователей.}
				\item{RequestLogServices --- класс реализации логики логирования изменений запроса администратором.}
				\item{RespondedPeopleServices --- класс реализации логики по работе с откликнувшимися на запрос.}
				\item{StudentRequestServices --- класс реализации логики студентов по взаимодействию с запросами.}
				\item{TokenServices --- класс реализации логики работы с токенами.}
				\item{UserServices --- класс реализации логики по взаимодействию данными пользователей.}
			\end{itemize}
		}
	\item{Interfaces --- это интерфейсы логики приложения.
			\begin{itemize}
				\item{IAdminRequestServices}
				\item{IAdminUserServices}
				\item{IAuthServices}
				\item{ICachingServices}
				\item{IDevUserServices}
				\item{IHashingServices}
				\item{IRequestLogServices}
				\item{IRespondedPeopleServices}
				\item{IStudentRequestServices}
				\item{ITokenServices}
				\item{IUserServices}
			\end{itemize}
		}
\end{itemize}

\subsubsection{Реализация JWT.}
% NOTE: JWT
Данная реализация JWT состоит из двух токенов:
\begin{enumerate}
	\item{\textbf{Access Token} --- короткоживущий (5 минут) токен, содержит основные claims (Id, имя пользователя, роль).}
	\item{\textbf{Refresh Token} --- долгоживущий (24 часа) токен, содержит аналогичные claims, но с дополнительным Jti (уникальный идентификатор).}
\end{enumerate}

Access Token используется для аутентификации пользователя и получения разрешения на доступ к защищенному ресурсу. Refresh Token используется для обновления Access Token в случае его устаревания. Так же для предотвращения использования украденных валидных Refresh Token, данный токен сохраняется в базе данных и удаляется при выходе пользователя из системы или повторном входе, что обеспечивает его недействительность и исключает возможность повторного применения после завершения сессии.

% NOTE: Генерация токенов:
\textbf{Генерация токенов:} По данным пользователя генерируются токены с учетом их времени жизни и соответствующими секретным ключам.
\begin{minted}{cs}
    private string GenerateAccessToken(User user, string secretKey)
    {
        var claims = GenerateClaimsAccess(user);
        var token = GenerateToken(claims, secretKey, accessTokenTime);
        return new JwtSecurityTokenHandler().WriteToken(token);
    }

    private string GenerateRefreshToken(User user, string secretKey)
    {
        var claims = GenerateClaimsRefresh(user);
        var token = GenerateToken(claims, secretKey + "sault", refreshTokenTime);
        return new JwtSecurityTokenHandler().WriteToken(token);
    }
\end{minted}
% \textbf{Подпись токенов:}
% \begin{enumerate}
% 	\item{Access Token подписывается с помощью ключа secretKey хранящегося в appsettings.json.}
% 	\item{Refresh Token подписывается с помощью того же ключа secretKey + строки "sault".}
% \end{enumerate}

% NOTE: Валидация Refresh Token 
\textbf{Валидация Refresh Token:} Если Refresh Token валиден, то возвращает Ok, если просрочен, то Ok с описанием, что время жизни токена истекло, иначе BadRequest с описанием, что токен невалидный.
\begin{minted}{cs}
    private BaseResponse<Tokens> ValidateRefreshToken(string token, string secretKey)
    {
        var tokenHandler = new JwtSecurityTokenHandler();
        var validationParameters = new TokenValidationParameters
        {
            ValidateIssuerSigningKey = true,
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.ASCII.GetBytes(secretKey + "sault")),
            ValidateIssuer = false,
            ValidateAudience = false,
            ClockSkew = TimeSpan.Zero
        };
        try
        {
            // Проверка подписи JWT, если токен не верный будет исключение
            tokenHandler.ValidateToken(token, validationParameters, out _);
            return BaseResponse<Tokens>.Ok();
        }
        catch (SecurityTokenExpiredException ex)
        {
            return BaseResponse<Tokens>.Ok(description: "Token expired");
        }
        catch (SecurityTokenException ex)
        {
            return BaseResponse<Tokens>.BadRequest(description: "Tokens not valid");
        }
    }
\end{minted}

% NOTE: Обновление токенов:
\textbf{Обновление токенов:} Обновление токенов состоит из нескольких этапов:
\begin{itemize}
	\item{Проверка токена на валидность;}
\end{itemize}
\begin{minted}{cs}
    public async Task<IBaseResponse<Tokens>> RefreshToken(string oldRefreshToken, string secretKey)
    {
        BaseResponse<Tokens> response = ValidateRefreshToken(oldRefreshToken, secretKey);

        // Если oldRefreshToken невалидный
        if (response.StatusCode == StatusCodes.BadRequest)
        {
            return response;
        }
\end{minted}

\begin{itemize}
	\item{Перенос данных из Refresh Token в User для дальнейшего создания Access Token по этим данным:}
\end{itemize}
\begin{minted}{cs}
        var oldToken = new JwtSecurityTokenHandler().ReadJwtToken(oldRefreshToken);
        User user = new User();
        // Заполняем user на основе данных из oldRefreshToken
        user.Id = Convert.ToInt32(oldToken.Claims.First(
                    claim => claim.Type == JwtRegisteredClaimNames.Sub
                    ).Value);
        user.Name = Convert.ToString(oldToken.Claims.First(
                    claim => claim.Type == JwtRegisteredClaimNames.Name
                    ).Value);
        user.Role = Convert.ToString(oldToken.Claims.First(
                    claim => claim.Type == ClaimTypes.Role
                    ).Value);
\end{minted}

\begin{itemize}
	\item{Проверка на нахождение Refresh Token в базе данных (если его там нет, то считаем недействительным):}
\end{itemize}
\begin{minted}{cs}
        // Находим oldRefreshToken
        var oldRefreshDB = await _RefreshTokenRepository.FirstOrDefaultAsync(token => token.Token == oldRefreshToken);
        if (oldRefreshDB == null)
        {
            response = BaseResponse<Tokens>.NotFound();
            return response;
        }
\end{minted}

\begin{itemize}
	\item{Обновление Refresh Token, если токен не просрочен:}
\end{itemize}
\begin{minted}{cs}
        var oldTokenDB = new JwtSecurityTokenHandler().ReadJwtToken(oldRefreshDB.Token);

        // Оставляем старый refreshToken, или в случае просрока заменим далее
        string refreshToken = oldRefreshDB.Token;
        if (response.Description == "Token expired")
        {
            // Удаляем oldRefreshToken, если тот истек
            await _RefreshTokenRepository.Delete(oldRefreshDB);
            // Пересоздаем oldRefreshToken, если тот истек
            refreshToken = GenerateRefreshToken(user, secretKey);

            RefreshToken saveRefreshToken = new RefreshToken
            {
                Id = user.Id,
                Token = refreshToken
            };
            // Сохраняем новый refreshToken в бд
            await _RefreshTokenRepository.Create(saveRefreshToken);
        }
\end{minted}

\begin{itemize}
	\item{Создание Access Token по данным извлеченным из Refresh Token:}
\end{itemize}
\begin{minted}{cs}
        string accessToken = GenerateAccessToken(user, secretKey);
        response = BaseResponse<Tokens>.Ok(new Tokens
        {
            AccessToken = accessToken,
            RefreshToken = refreshToken
        });
        return response;
    }
\end{minted}

% NOTE: Удаление Refresh Token из бд: 
\textbf{Удаление Refresh Token из бд:} Удаление Refresh Token из базы данных по Id пользователя:
\begin{minted}{cs}
    public async Task<IBaseResponse> DeleteRefreshToken(int userId)
    {
        BaseResponse response;

        var refreshToken = await _RefreshTokenRepository.FirstOrDefaultAsync(token => token.Id == userId);

        if (refreshToken == null)
        {
            response = BaseResponse.NoContent();
            return response;
        }
        await _RefreshTokenRepository.Delete(refreshToken);

        response = BaseResponse.Ok();
        return response;
    }
\end{minted}

\subsubsection{Реализация ленты запросов, для администраторов и пользователей.}

% NOTE: Лента админов
\textbf{Лента админов:} Если есть запросы и откликнувшиеся на них люди, то объединяем их в List<PrivateReqest> и далее выводим.
\begin{minted}{cs}
				// Получаем откликнувшихся на запросы
        var respondedPeople = await _RespondedPeopleRepository.GetAll();

        List<PrivateRequest> requests;

        // Если есть откликнувшеся люди
        if (respondedPeople != null && respondedPeople.Count > 0)
        {
            // Ищем в БД
            requests = await _RequestRepository
                .GetQueryable()
                .Select(request => new PrivateRequest(request, respondedPeople)) // Преобразуем в PrivateRequest с откликнувшимися людьми
                .ToListAsync();
        }
        else
        {
            // Ищем в БД
            requests = await _RequestRepository
                .GetQueryable()
                .Select(request => new PrivateRequest(request)) // Преобразуем в PrivateRequest без откликнувшихся людей
                .ToListAsync();
        }
\end{minted}

\textbf{Лента пользователей:}  Если есть запросы и откликнувшиеся на них люди, то объединяем их в List<PublicRequest> и далее выводим.
\begin{minted}{cs}
				// Получаем откликнувшихся на запросы
        var respondedPeople = await _RespondedPeopleRepository.GetAll();

        List<PublicRequest> requests;

        // Если есть откликнувшеся люди
        if (respondedPeople != null && respondedPeople.Count > 0)
        {
            // Ищем в БД
            requests = await _RequestRepository
                .GetQueryable()
                .Select(request => new PublicRequest(request, respondedPeople)) // Преобразуем в PublicRequest с откликнувшимися людьми
                .ToListAsync();
        }
        else
        {
            // Ищем в БД
            requests = await _RequestRepository
                .GetQueryable()
                .Select(request => new PublicRequest(request)) // Преобразуем в PublicRequest без откликнувшихся людей
                .ToListAsync();
        }
\end{minted}

\subsubsection{Реализация возможности записаться на запрос и отписаться с запроса.}

\textbf{Добавление пользователя к запросу:} добавление пользователя к запросу состоит из нескольких этапов:
\begin{itemize}
	\item{Ищем запрос в БД:}
\end{itemize}
\begin{minted}{cs}
    // Добавить Id студента в откликнувшихся на запрос
    public async Task<IBaseResponse> AssignMe(int requestId)
    {
        BaseResponse response;

        // Ищем запрос в БД
        var request = await _RequestRepository.FirstOrDefaultAsync(rq => rq.Id == requestId);

        // Если запроса нет
        if (request == null)
        {
            // NotFound (404)
            response = BaseResponse.NotFound("Request not found");
            return response;
        }

\end{minted}

\begin{itemize}
	\item{Если запрос найден, ищем откликнувшихся на данный запрос:}
\end{itemize}
\begin{minted}{cs}
        // Нашли запрос
        // Ищем откликнувшихся на запрос
        var respondedPeople = await _RespondedPeopleRepository
            .Where(rp => rp.RequestId == requestId)
            .ToListAsync();
\end{minted}

\begin{itemize}
	\item{Если остались места и студент не откликался на запрос, то добавляем его в откликнувшихся:}
\end{itemize}
\begin{minted}{cs}
        // Если остались места
        if (respondedPeople.Count < request.NeededPeopleNumber)
        {
            // Получаем Id откликнувшегося студента из токена
            int myId = _UserServices.GetMyId();
            // Если студент уже откликался
            if (respondedPeople.Where(rp => rp.UserId == myId).Any())
            {
                // BadRequest (400)
                response = BaseResponse.BadRequest("Already added");
                return response;
            }

            // Добавляем студента к откликнувшимся
            RespondedPeople newRP = new RespondedPeople();
            newRP.RequestId = requestId;
            newRP.UserId = myId;
            await _RespondedPeopleRepository.Create(newRP);

            // NoContent (204)
            response = BaseResponse.NoContent("Successed");
            return response;
        }
        // BadRequest (400)
        response = BaseResponse.BadRequest("No more places");
        return response;
    }
\end{minted}

\subsubsection{Реализация начисления очков за выполненный запрос.}

\textbf{Начисление очков за выполненный запрос:} Начисляем очки за выполненный запрос состоит из нескольких этапов:

\begin{itemize}
	\item{Ищем запрос в БД и проверяем его наличие и возможность закрыть его как выполненный:}
\end{itemize}
\begin{minted}{cs}
        var request = await _RequestRepository.FirstOrDefaultAsync(rq => rq.Id == requestId);
        if (request == null)
        {
            response = BaseResponse.NotFound("Request not found");
            return response;
        }
        if (usersId.Count > request.NeededPeopleNumber)
        {
            response = BaseResponse.UnprocessableContent("Number of Ids is more than necessary");
            return response;
        }
        if (request.IsComplited == true)
        {
            response = BaseResponse.BadRequest("Request is already Completed");
            return response;
        }
        if (request.IsFailed == true)
        {
            response = BaseResponse.BadRequest("Request is already Failed");
            return response;
        }
\end{minted}
\begin{itemize}
	\item{Вызываем метод начисления очков за выполненный запрос:}
\end{itemize}
\begin{minted}{cs}
        response = await PointsPerRequest(request.PointNumber, usersId);
\end{minted}

\begin{itemize}
	\item{Находим всех пользователей из списка Id и если они все существуют, то начисляем им очки за выполнение запроса:}
\end{itemize}
\begin{minted}{cs}
    private async Task<IBaseResponse> PointsPerRequest(int points, List<int> usersId)
    {
        BaseResponse response;
        List<User> users = new List<User>();
        User user;

        for (int i = 0; i < usersId.Count; i++)
        {
            user = await _UserRepository.FirstOrDefaultAsync(us => us.Id == usersId[i]);

            if (user == null)
            {
                response = BaseResponse.NotFound("User is not found");
                return response;
            }

            user.Points += points;
        }

				// Если все пользователи существуют
        for (int i = 0; i < users.Count; i++)
        {
            await _UserRepository.Update(users[i]);
        }
        response = BaseResponse.NoContent();
        return response;
    }
\end{minted}

\begin{itemize}
	\item{Отмечаем запрос как выполненный, сохраняем изменение запроса в бд и логируем изменение запроса в файл:}
\end{itemize}
\begin{minted}{cs}
        request.IsComplited = true;

        await _RequestRepository.Update(request);

        RequestLog log = new RequestLog(0, request.AdminId, request.Id, $"Request MarkAsCompleted");

        _RequestLogServices.AppendLogToFile(log);
\end{minted}

\subsubsection{Реализация логирования изменений запроса администратором.}

% \textbf{Создание директории для логов и самого лог файла:} Создает директорию для логов и сам лог файл, если они еще не существуют:
% \begin{minted}{cs}
%     // Создаем директорию, если ее нет
%     private void EnsureDirectoryExist()
%     {
%         if (!Directory.Exists(LogsDir))
%         {
%             Directory.CreateDirectory(LogsDir);
%         }
%     }
%
%     // Создаем файл, если его нет
%     private static void EnsureFileExist(string pathToLog)
%     {
%         if (!File.Exists(pathToLog))
%         {
%             File.Create(pathToLog).Close(); // Закрываем поток после создания
%         }
%     }
% \end{minted}

\textbf{Создание пути к файлу:} Создаем путь к файлу по Id запроса:
\begin{minted}{cs}
    private string CreatePathToLog(int requestId)
    {
        // Путь до файла
        string fileName = TemplateLogFileName + requestId.ToString() + ".log";
        string pathToLog = Path.Combine(LogsDir, fileName);

        return pathToLog;
    }
\end{minted}

\textbf{Добавление лога в файл:} Добавляем переданный в метод лог в файл последней строкой:
\begin{minted}{cs}
    // Добавить RequestLog последней строкой
    public void AppendLogToFile(RequestLog log)
    {
        // Путь до файла
        string pathToLog = CreatePathToLog(log.RequestId);

        // Находим последний log Id
        RequestLog lastLog = ReadLastLogFromFile(pathToLog);
        // Задаем новый log Id для новой записи
        log.Id = lastLog.Id + 1;

        EnsureFileExist(pathToLog);

        string newLog = $"{log.Id}, {log.AdminId}, {log.RequestId}, {AddEscaping(log.Action)}, {log.Date:O}";

        File.AppendAllText(pathToLog, newLog + Environment.NewLine);
    }
\end{minted}

\textbf{Парсинг лога из файла:} Парсинг строки лога из файла в класс RequestLog:
\begin{minted}{cs}
    private static RequestLog ParseLogLine(string logLine)
    {
        var parts = logLine.Split(",");
        return new RequestLog(
                int.Parse(parts[0]),
                int.Parse(parts[1]),
                int.Parse(parts[2]),
                RemoveEscaping(parts[3]),
                DateTime.Parse(parts[4])
        );
    }
\end{minted}

\textbf{Чтение логов из файла:} Чтение всех логов запроса по его Id, возвращает List из логов
\begin{minted}{cs}
    // Получить все RequestLog данного Request
    public List<RequestLog> ReadAllLogsFromFile(int requestId)
    {
        // Путь до файла
        string pathToLog = CreatePathToLog(requestId);

        if (!File.Exists(pathToLog))
        {
            return new List<RequestLog>();
        }

        return File.ReadAllLines(pathToLog)
            .Where(line => !string.IsNullOrEmpty(line))
            .Select(ParseLogLine)
            .ToList();
    }
\end{minted}

\textbf{Удаление файла лога:} Удаляем файл по Id запроса:
\begin{minted}{cs}
    public void DeleteLogFile(int requestId)
    {
        // Путь до файла
        string pathToLog = CreatePathToLog(requestId);

        if (File.Exists(pathToLog))
        {
            File.Delete(pathToLog);
        }
    }
\end{minted}

\subsubsection{Реализация повшения до администратора и понижения до пользователя.}
